<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Snake Sprint (One-Button Snake) - Easy Mode</title>
<style>
  body {
    margin: 0; background: #111; display: flex; flex-direction: column; align-items: center; height: 100vh;
    color: #eee; font-family: monospace;
    user-select: none;
  }
  canvas {
    background: #222;
    image-rendering: pixelated;
    border: 2px solid #555;
    margin-top: 20px;
  }
  #info {
    font-size: 16px;
    text-align: center;
    user-select: none;
    margin-top: 10px;
  }
  #scoreboard {
    margin-top: 15px;
    text-align: center;
  }
  #scoreboard h2 {
    margin: 0 0 5px 0;
  }
  #scoreboard ol {
    padding-left: 20px;
    margin: 0;
  }
  button {
    margin-top: 10px;
    padding: 6px 12px;
    font-size: 16px;
    cursor: pointer;
  }
  #gameMessage {
    color: #f88;
    font-size: 18px;
    margin-top: 10px;
    text-align: center;
    min-height: 24px;
  }
</style>
</head>
<body>

<div id="info">
  <div>Use Arrow Keys or swipe on mobile to change direction.<br>Press Space or Play/Pause button to start/pause.<br>Score: <span id="score">0</span></div>
</div>
<canvas id="game" width="400" height="400"></canvas>
<div id="gameMessage"></div>

<div id="scoreboard">
  <h2>High Scores</h2>
  <ol id="highScoresList"></ol>
</div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const highScoresList = document.getElementById('highScoresList');
  const infoDiv = document.getElementById('info');
  const gameMessage = document.getElementById('gameMessage');

  const CELL_SIZE = 20;
  const COLS = canvas.width / CELL_SIZE;
  const ROWS = canvas.height / CELL_SIZE;

  // Directions as vectors
  const DIRS = {
    right: { x: 1, y: 0 },
    down: { x: 0, y: 1 },
    left: { x: -1, y: 0 },
    up: { x: 0, y: -1 },
  };

  // Game variables
  let snake, direction, food, obstacles, score, foodTimer;
  const FOOD_LIFETIME = 12000; // 12 seconds before food disappears
  const OBSTACLE_COUNT = 7; // fewer obstacles for easy mode
  const FPS = 6; // slower speed
  let gameInterval = null;
  let isPaused = true; // Start paused until Play is clicked

  // High score tracking (session only)
  let highScores = [];

  // Create Play/Pause button
  const playPauseBtn = document.createElement('button');
  playPauseBtn.textContent = 'Play';
  infoDiv.appendChild(playPauseBtn);

  function reset() {
    snake = [
      { x: Math.floor(COLS / 2) - 1, y: Math.floor(ROWS / 2) },
    ];
    direction = DIRS.right;
    score = 0;
    scoreEl.textContent = score;
    generateObstacles();
    placeFood();
  }

  function generateObstacles() {
    obstacles = [];
    while (obstacles.length < OBSTACLE_COUNT) {
      const pos = { x: randInt(0, COLS - 1), y: randInt(0, ROWS - 1) };
      if (
        snake.some((s) => s.x === pos.x && s.y === pos.y) ||
        obstacles.some((o) => o.x === pos.x && o.y === pos.y)
      )
        continue;
      obstacles.push(pos);
    }
  }

  function placeFood() {
    let tries = 0;
    do {
      food = { x: randInt(0, COLS - 1), y: randInt(0, ROWS - 1) };
      tries++;
      if (tries > 100) break; // fallback
    } while (
      snake.some((s) => s.x === food.x && s.y === food.y) ||
      obstacles.some((o) => o.x === food.x && o.y === food.y)
    );
    foodTimer = Date.now();
  }

  function randInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  function drawCell(x, y, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw obstacles
    for (const o of obstacles) {
      drawCell(o.x, o.y, '#664422');
    }

    // Draw food (blink if almost expired)
    const timeLeft = FOOD_LIFETIME - (Date.now() - foodTimer);
    if (timeLeft > 0) {
      if (timeLeft < 1500 && Math.floor(Date.now() / 200) % 2 === 0) {
        // blink effect near expiration (skip drawing food)
      } else {
        drawCell(food.x, food.y, '#FF5555');
      }
    }

    // Draw snake
    snake.forEach((segment, i) => {
      drawCell(segment.x, segment.y, i === snake.length - 1 ? '#00FF00' : '#009900');
    });
  }

  function update() {
    const head = snake[snake.length - 1];
    const newHead = { x: head.x + direction.x, y: head.y + direction.y };

    // Check collisions
    if (
      newHead.x < 0 ||
      newHead.x >= COLS ||
      newHead.y < 0 ||
      newHead.y >= ROWS ||
      snake.some((s) => s.x === newHead.x && s.y === newHead.y) ||
      obstacles.some((o) => o.x === newHead.x && o.y === newHead.y)
    ) {
      gameOver();
      return;
    }

    snake.push(newHead);

    // Check if ate food and food still valid
    if (
      food &&
      newHead.x === food.x &&
      newHead.y === food.y &&
      Date.now() - foodTimer <= FOOD_LIFETIME
    ) {
      score++;
      scoreEl.textContent = score;
      placeFood();
    } else {
      snake.shift();
    }

    // If food expired, place new food
    if (food && Date.now() - foodTimer > FOOD_LIFETIME) {
      placeFood();
    }
  }

  // Change direction only if not reversing directly
  function setDirection(newDir) {
    if (
      (direction.x + newDir.x === 0 && direction.y + newDir.y === 0) // Prevent reversing
    ) return;
    direction = newDir;
  }

  function gameOver() {
    pauseGame();
    gameMessage.textContent = `Game Over! Your score: ${score}`;
    addHighScore(score);
    reset();
    draw();
  }

  function addHighScore(score) {
    highScores.push(score);
    highScores.sort((a, b) => b - a);
    if (highScores.length > 5) highScores.length = 5;
    updateHighScoresUI();
  }

  function updateHighScoresUI() {
    highScoresList.innerHTML = highScores.map((s) => `<li>${s}</li>`).join('');
  }

  function loop() {
    update();
    draw();
  }

  // Keyboard input - direct direction control + space toggle pause
  window.addEventListener('keydown', (e) => {
    switch (e.code) {
      case 'ArrowUp':
        e.preventDefault();
        setDirection(DIRS.up);
        break;
      case 'ArrowDown':
        e.preventDefault();
        setDirection(DIRS.down);
        break;
      case 'ArrowLeft':
        e.preventDefault();
        setDirection(DIRS.left);
        break;
      case 'ArrowRight':
        e.preventDefault();
        setDirection(DIRS.right);
        break;
      case 'Space':
        e.preventDefault();
        togglePause();
        break;
    }
  });

  // Swipe detection for mobile to control direction
  let touchStartX = null;
  let touchStartY = null;
  const MIN_SWIPE_DISTANCE = 30; // minimum px for a swipe

  window.addEventListener('touchstart', (e) => {
    if (e.touches.length === 1) {
      touchStartX = e.touches[0].clientX;
      touchStartY = e.touches[0].clientY;
    }
  }, { passive: true });

  window.addEventListener('touchmove', (e) => {
    if (!touchStartX || !touchStartY) return;

    const touchEndX = e.touches[0].clientX;
    const touchEndY = e.touches[0].clientY;

    const dx = touchEndX - touchStartX;
    const dy = touchEndY - touchStartY;

    if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > MIN_SWIPE_DISTANCE) {
      // Horizontal swipe
      if (dx > 0) {
        setDirection(DIRS.right);
      } else {
        setDirection(DIRS.left);
      }
      touchStartX = null;
      touchStartY = null;
    } else if (Math.abs(dy) > MIN_SWIPE_DISTANCE) {
      // Vertical swipe
      if (dy > 0) {
        setDirection(DIRS.down);
      } else {
        setDirection(DIRS.up);
      }
      touchStartX = null;
      touchStartY = null;
    }
  }, { passive: true });

  // Play/Pause button event
  playPauseBtn.addEventListener('click', () => {
    togglePause();
  });

  function playGame() {
    if (!gameInterval) {
      gameMessage.textContent = '';  // clear game over message on play
      gameInterval = setInterval(loop, 1000 / FPS);
      isPaused = false;
      playPauseBtn.textContent = 'Pause';
    }
  }

  function pauseGame() {
    if (gameInterval) {
      clearInterval(gameInterval);
      gameInterval = null;
      isPaused = true;
      playPauseBtn.textContent = 'Play';
    }
  }

  function togglePause() {
    if (isPaused) {
      playGame();
    } else {
      pauseGame();
    }
  }

  // Initialize game
  reset();
  draw();
})();
</script>

</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <!-- SEO Meta Tags -->
  <title>Lava Dash - Epic Endless Runner Game | Play Free Online</title>
  <meta name="description" content="Play Lava Dash, the thrilling endless runner game! Jump between walls, collect golden coins, avoid deadly spikes and rising lava. Test your reflexes in this addictive arcade game.">
  <meta name="keywords" content="lava dash, endless runner, arcade game, jump game, online game, free game, mobile game, reflexes, coins, spikes">
  <meta name="author" content="Lava Dash Game">
  <meta name="robots" content="index, follow">
  
  <!-- Open Graph Meta Tags -->
  <meta property="og:title" content="Lava Dash - Epic Endless Runner Game">
  <meta property="og:description" content="Jump between walls, collect coins, and survive the rising lava in this thrilling endless runner!">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://example.com/lava-dash">
  <meta property="og:image" content="https://example.com/lava-dash-preview.jpg">
  
  <!-- Twitter Card Meta Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Lava Dash - Epic Endless Runner Game">
  <meta name="twitter:description" content="Jump between walls, collect coins, and survive the rising lava!">
  <meta name="twitter:image" content="https://example.com/lava-dash-preview.jpg">
  
  <!-- Favicon -->
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üî•</text></svg>">
  
  <!-- Schema.org JSON-LD -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "VideoGame",
    "name": "Lava Dash",
    "description": "An exciting endless runner game where players jump between walls to avoid spikes and rising lava while collecting coins.",
    "genre": "Arcade",
    "playMode": "SinglePlayer",
    "applicationCategory": "Game",
    "operatingSystem": "Web Browser",
    "offers": {
      "@type": "Offer",
      "price": "0",
      "priceCurrency": "USD"
    }
  }
  </script>

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;400;600;700&display=swap');
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body, html {
      height: 100vh;
      overflow: hidden;
      background: linear-gradient(135deg, #0a0a0a 0%, #1a0e0e 50%, #2d1b1b 100%);
      font-family: 'Rajdhani', sans-serif;
      user-select: none;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: fixed;
      width: 100%;
      top: 0;
      left: 0;
    }

    .game-container {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
      padding: 10px;
      width: 100%;
      height: 100vh;
      justify-content: center;
      max-width: 500px;
    }

    .game-header {
      text-align: center;
      margin-bottom: 10px;
      z-index: 10;
    }

    .game-title {
      font-family: 'Orbitron', monospace;
      font-size: clamp(1.5rem, 4vw, 2.5rem);
      font-weight: 900;
      background: linear-gradient(45deg, #ff6b35, #f7931e, #ffcc02, #ff6b35);
      background-size: 300% 300%;
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: 0 0 30px rgba(255, 107, 53, 0.3);
      animation: gradientShift 3s ease-in-out infinite;
      margin-bottom: 5px;
      letter-spacing: 2px;
    }

    .game-subtitle {
      font-size: clamp(0.8rem, 1.5vw, 1rem);
      color: #ff8a65;
      font-weight: 300;
      opacity: 0.9;
      letter-spacing: 1px;
    }

    @keyframes gradientShift {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }

    .game-canvas-container {
      position: relative;
      border-radius: 15px;
      overflow: hidden;
      box-shadow: 
        0 0 30px rgba(255, 107, 53, 0.4),
        0 0 60px rgba(255, 107, 53, 0.2),
        inset 0 0 30px rgba(0, 0, 0, 0.5);
      background: linear-gradient(145deg, #2a1515, #1a0f0f);
      padding: 6px;
      width: 100%;
      max-width: 350px;
      aspect-ratio: 2/3;
    }

    canvas {
      display: block;
      border-radius: 10px;
      background: linear-gradient(180deg, #4a1a1a 0%, #2d0000 30%, #660000 60%, #990000 100%);
      image-rendering: pixelated;
      box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.8);
      width: 100%;
      height: 100%;
    }

    .game-ui {
      position: absolute;
      top: 15px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 15px;
      z-index: 15;
      pointer-events: none;
    }

    .ui-element {
      background: linear-gradient(145deg, rgba(255, 107, 53, 0.9), rgba(255, 140, 101, 0.8));
      padding: 8px 12px;
      border-radius: 20px;
      backdrop-filter: blur(10px);
      border: 2px solid rgba(255, 255, 255, 0.2);
      box-shadow: 
        0 6px 20px rgba(0, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.2);
      min-width: 60px;
      text-align: center;
    }

    .ui-label {
      font-size: 0.7rem;
      color: #fff;
      opacity: 0.9;
      font-weight: 400;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 2px;
    }

    .ui-value {
      font-size: 1.1rem;
      color: #fff;
      font-weight: 700;
      font-family: 'Orbitron', monospace;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    .control-panel {
      display: flex;
      gap: 15px;
      align-items: center;
      justify-content: center;
      flex-wrap: wrap;
      z-index: 10;
      margin-top: 5px;
    }

    .play-button {
      background: linear-gradient(145deg, #ff6b35, #f7931e);
      border: none;
      color: white;
      padding: 12px 24px;
      font-family: 'Orbitron', monospace;
      font-size: 0.9rem;
      font-weight: 700;
      cursor: pointer;
      border-radius: 40px;
      box-shadow: 
        0 6px 20px rgba(255, 107, 53, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.2);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      text-transform: uppercase;
      letter-spacing: 2px;
      position: relative;
      overflow: hidden;
      min-width: 120px;
    }

    .play-button::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
      transition: left 0.5s;
    }

    .play-button:hover::before {
      left: 100%;
    }

    .play-button:hover {
      transform: translateY(-2px);
      box-shadow: 
        0 8px 25px rgba(255, 107, 53, 0.5),
        inset 0 1px 0 rgba(255, 255, 255, 0.3);
    }

    .play-button:active {
      transform: translateY(-1px);
    }

    .instructions {
      background: linear-gradient(145deg, rgba(0, 0, 0, 0.7), rgba(26, 15, 15, 0.8));
      padding: 15px 20px;
      border-radius: 15px;
      backdrop-filter: blur(15px);
      border: 1px solid rgba(255, 107, 53, 0.3);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.5);
      text-align: center;
      max-width: 350px;
      width: 100%;
    }

    .instructions-title {
      font-family: 'Orbitron', monospace;
      font-size: 1.1rem;
      font-weight: 700;
      color: #ff8a65;
      margin-bottom: 10px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .instructions-text {
      color: #e0e0e0;
      font-size: 0.9rem;
      line-height: 1.5;
      margin-bottom: 10px;
    }

    .instruction-controls {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-top: 10px;
      flex-wrap: wrap;
    }

    .control-key {
      background: linear-gradient(145deg, #333, #555);
      padding: 6px 10px;
      border-radius: 8px;
      font-family: 'Orbitron', monospace;
      font-size: 0.8rem;
      color: #fff;
      border: 1px solid #666;
      box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
    }

    .game-over-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(26, 15, 15, 0.9));
      backdrop-filter: blur(10px);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 20;
      opacity: 0;
      visibility: hidden;
      transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .game-over-overlay.show {
      opacity: 1;
      visibility: visible;
    }

    .game-over-title {
      font-family: 'Orbitron', monospace;
      font-size: clamp(2rem, 6vw, 3rem);
      font-weight: 900;
      color: #ff4444;
      text-shadow: 0 0 30px rgba(255, 68, 68, 0.5);
      margin-bottom: 20px;
      animation: pulse 2s ease-in-out infinite;
    }

    .game-over-stats {
      display: flex;
      gap: 20px;
      margin-bottom: 25px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .stat-card {
      background: linear-gradient(145deg, rgba(255, 107, 53, 0.2), rgba(255, 140, 101, 0.1));
      padding: 15px;
      border-radius: 12px;
      border: 1px solid rgba(255, 107, 53, 0.3);
      text-align: center;
      min-width: 100px;
    }

    .stat-card h3 {
      font-family: 'Orbitron', monospace;
      color: #ff8a65;
      font-size: 0.9rem;
      margin-bottom: 5px;
    }

    .stat-card p {
      font-size: 1.5rem;
      font-weight: 700;
      color: #fff;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }

    .particles {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1;
    }

    .particle {
      position: absolute;
      width: 3px;
      height: 3px;
      background: #ff6b35;
      border-radius: 50%;
      animation: float 6s linear infinite;
      opacity: 0.6;
    }

    @keyframes float {
      0% {
        transform: translateY(100vh) rotate(0deg);
        opacity: 0;
      }
      10% {
        opacity: 0.6;
      }
      90% {
        opacity: 0.6;
      }
      100% {
        transform: translateY(-10vh) rotate(360deg);
        opacity: 0;
      }
    }

    /* Mobile Responsive */
    @media (max-width: 768px) {
      .game-container {
        padding: 8px;
        gap: 8px;
      }

      .game-ui {
        gap: 12px;
        top: 12px;
      }

      .ui-element {
        padding: 6px 10px;
        min-width: 50px;
      }

      .ui-label {
        font-size: 0.6rem;
      }

      .ui-value {
        font-size: 1rem;
      }

      .instructions {
        padding: 12px 16px;
        max-width: 95vw;
      }

      .play-button {
        padding: 10px 20px;
        font-size: 0.8rem;
        min-width: 100px;
      }

      .control-panel {
        gap: 12px;
      }

      .game-over-stats {
        gap: 15px;
      }

      .stat-card {
        padding: 12px;
        min-width: 80px;
      }
    }

    @media (max-width: 480px) {
      .game-canvas-container {
        padding: 4px;
        max-width: 95vw;
      }

      .instructions-text {
        font-size: 0.8rem;
      }

      .control-key {
        padding: 5px 8px;
        font-size: 0.7rem;
      }

      .game-header {
        margin-bottom: 5px;
      }

      .control-panel {
        margin-top: 2px;
      }
    }

    /* Landscape mobile optimization */
    @media (max-height: 600px) and (orientation: landscape) {
      .game-container {
        flex-direction: row;
        gap: 15px;
        padding: 10px;
      }

      .game-canvas-container {
        max-width: 50vw;
        aspect-ratio: 3/4;
      }

      .game-header {
        margin-bottom: 0;
      }

      .instructions {
        max-width: 40vw;
      }
    }

    /* Loading Animation */
    .loading {
      display: inline-block;
      width: 16px;
      height: 16px;
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      border-top-color: #fff;
      animation: spin 1s ease-in-out infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <div class="particles" id="particles"></div>
  
  <div class="game-container">
    <div class="game-header">
      <h1 class="game-title">ü•∑ NINJA LAVA DASH</h1>
      <p class="game-subtitle">Master the Ancient Art of Survival</p>
    </div>

    <div class="game-canvas-container">
      <canvas id="game" width="300" height="450"></canvas>
      
      <div class="game-ui">
        <div class="ui-element">
          <div class="ui-label">Score</div>
          <div class="ui-value" id="scoreDisplay">0</div>
        </div>
        <div class="ui-element">
          <div class="ui-label">Coins</div>
          <div class="ui-value" id="coinsDisplay">0</div>
        </div>
        <div class="ui-element">
          <div class="ui-label">Speed</div>
          <div class="ui-value" id="speedDisplay">1.2</div>
        </div>
      </div>

      <div class="game-over-overlay" id="gameOverOverlay">
        <h2 class="game-over-title">GAME OVER</h2>
        <div class="game-over-stats">
          <div class="stat-card">
            <h3>Final Score</h3>
            <p id="finalScore">0</p>
          </div>
          <div class="stat-card">
            <h3>Coins Collected</h3>
            <p id="finalCoins">0</p>
          </div>
        </div>
        <button class="play-button" onclick="restartGame()">
          üîÑ PLAY AGAIN
        </button>
      </div>
    </div>

    <div class="control-panel">
      <button class="play-button" id="playPauseBtn">
        ‚ñ∂Ô∏è START GAME
      </button>
    </div>

    <div class="instructions">
      <h3 class="instructions-title">ü•∑ How to Play</h3>
      <p class="instructions-text">Control the ninja! Jump between walls to avoid deadly obstacles and collect golden coins. The lava rises constantly - stay above it to survive!</p>
      <div class="instruction-controls">
        <span class="control-key">SPACE</span>
        <span class="control-key">TAP</span>
        <span class="control-key">CLICK</span>
      </div>
    </div>
  </div>

  <script>
    // Audio Manager Class
    class GameAudio {
      constructor() {
        this.sounds = {};
        this.enabled = true;
        this.audioContext = null;
        this.initAudio();
      }

      initAudio() {
        try {
          this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
          this.createSounds();
        } catch (e) {
          console.log('Web Audio API not supported');
          this.enabled = false;
        }
      }

      createSounds() {
        this.sounds = {
          jump: () => this.playTone(440, 0.1, 'triangle'), // Ninja jump
          collect: () => this.playSequence([523, 659, 784], 0.08), // Coin collect
          death: () => this.playNoise(0.5), // Game over
          background: () => this.playTone(220, 0.3, 'sine'), // Ambience
          slash: () => this.playTone(880, 0.05, 'sawtooth'), // Ninja move
          danger: () => this.playTone(150, 0.2, 'square') // Obstacle warning
        };
      }

      playTone(frequency, duration, type = 'sine') {
        if (!this.enabled || !this.audioContext) return;

        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(this.audioContext.destination);

        oscillator.frequency.value = frequency;
        oscillator.type = type;

        gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
        gainNode.gain.linearRampToValueAtTime(0.15, this.audioContext.currentTime + 0.01);
        gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + duration);

        oscillator.start(this.audioContext.currentTime);
        oscillator.stop(this.audioContext.currentTime + duration);
      }

      playSequence(frequencies, noteDuration) {
        if (!this.enabled) return;
        
        frequencies.forEach((freq, index) => {
          setTimeout(() => {
            this.playTone(freq, noteDuration * 0.8, 'triangle');
          }, index * noteDuration * 150);
        });
      }

      playNoise(duration) {
        if (!this.enabled || !this.audioContext) return;

        const bufferSize = this.audioContext.sampleRate * duration;
        const noiseBuffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
        const output = noiseBuffer.getChannelData(0);

        for (let i = 0; i < bufferSize; i++) {
          output[i] = Math.random() * 2 - 1;
        }

        const whiteNoise = this.audioContext.createBufferSource();
        const gainNode = this.audioContext.createGain();

        whiteNoise.buffer = noiseBuffer;
        whiteNoise.connect(gainNode);
        gainNode.connect(this.audioContext.destination);

        gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + duration);

        whiteNoise.start(this.audioContext.currentTime);
        whiteNoise.stop(this.audioContext.currentTime + duration);
      }

      play(soundName) {
        if (this.sounds[soundName]) {
          this.sounds[soundName]();
        }
      }

      resume() {
        if (this.audioContext && this.audioContext.state === 'suspended') {
          this.audioContext.resume();
        }
      }
    }

    (() => {
      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');
      
      // Set up responsive canvas sizing
      function resizeCanvas() {
        const container = canvas.parentElement;
        const rect = container.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        
        // Set display size (css pixels)
        canvas.style.width = rect.width - 12 + 'px'; // Account for padding
        canvas.style.height = rect.height - 12 + 'px';
        
        // Set actual size in device pixels
        canvas.width = (rect.width - 12) * dpr;
        canvas.height = (rect.height - 12) * dpr;
        
        // Scale the drawing context
        ctx.scale(dpr, dpr);
      }

      // Initial resize and listen for window resize
      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);
      
      const W = () => canvas.width / (window.devicePixelRatio || 1);
      const H = () => canvas.height / (window.devicePixelRatio || 1);

      // Audio system
      const gameAudio = new GameAudio();

      // Constants (proportional to canvas size)
      const getWallXLeft = () => W() * 0.15;
      const getWallXRight = () => W() * 0.85;
      const getPlayerSize = () => Math.min(W(), H()) * 0.04;
      const getLavaHeight = () => H() * 0.06;
      const getObstacleSize = () => Math.min(W(), H()) * 0.035;
      const getCoinSize = () => Math.min(W(), H()) * 0.025;
      const getPlayerY = () => H() * 0.7;

      // Speed & gameplay
      const SCROLL_SPEED_MIN = 1.2;
      const SCROLL_SPEED_MAX = 3.5;
      const SPEED_INCREASE_RATE = 0.0008;

      let scrollSpeed = SCROLL_SPEED_MIN;
      let lastTime = 0;
      let score = 0;
      let coinsCollected = 0;
      let gameOver = false;
      let isPlaying = false;

      // Ninja player with animation
      const player = {
        side: 'left',
        x: getWallXLeft(),
        y: getPlayerY(),
        animFrame: 0,
        jumpAnimation: 0
      };

      let offsetY = 0;
      const getObstacleSpacing = () => H() * 0.25;
      const obstacleCount = 15;
      let obstacles = [];
      let coins = [];

      // UI Elements
      const scoreDisplay = document.getElementById('scoreDisplay');
      const coinsDisplay = document.getElementById('coinsDisplay');
      const speedDisplay = document.getElementById('speedDisplay');
      const playPauseBtn = document.getElementById('playPauseBtn');
      const gameOverOverlay = document.getElementById('gameOverOverlay');
      const finalScore = document.getElementById('finalScore');
      const finalCoins = document.getElementById('finalCoins');

      // Create floating particles
      function createParticles() {
        const particlesContainer = document.getElementById('particles');
        for (let i = 0; i < 12; i++) {
          const particle = document.createElement('div');
          particle.className = 'particle';
          particle.style.left = Math.random() * 100 + '%';
          particle.style.animationDelay = Math.random() * 6 + 's';
          particle.style.animationDuration = (Math.random() * 3 + 4) + 's';
          particlesContainer.appendChild(particle);
        }
      }

      function initObstacles() {
        obstacles = [];
        const spacing = getObstacleSpacing();
        for (let i = 0; i < obstacleCount; i++) {
          let y = -i * spacing;
          let side = (Math.random() > 0.5) ? 'left' : 'right';
          let type = Math.floor(Math.random() * 3); // 0: shuriken, 1: kunai, 2: fire trap
          obstacles.push({ y, side, type });
        }
      }

      function isSafePosition(side, y) {
        const spacing = getObstacleSpacing();
        for (const obs of obstacles) {
          const obsY = obs.y + offsetY;
          if (obs.side === side && Math.abs(obsY - y) < spacing / 2) {
            return false;
          }
        }
        if (y + offsetY > H() - getLavaHeight() - 40) return false;
        return true;
      }

      function initCoins() {
        coins = [];
        const spacing = getObstacleSpacing();
        for (let i = 0; i < obstacleCount; i++) {
          let baseY = -i * spacing - spacing / 3;
          let attempts = 0;
          while (attempts < 10) {
            const side = (Math.random() > 0.5) ? 'left' : 'right';
            const y = baseY + (Math.random() * spacing / 3);
            if (isSafePosition(side, y)) {
              coins.push({ y, side, collected: false });
              break;
            }
            attempts++;
          }
        }
      }

      function lavaTop() {
        return H() - getLavaHeight() + offsetY;
      }

      function jump() {
        if (gameOver || !isPlaying) return;
        player.side = (player.side === 'left') ? 'right' : 'left';
        player.x = (player.side === 'left') ? getWallXLeft() : getWallXRight();
        player.jumpAnimation = 15; // Animation frames
        gameAudio.play('jump');
      }

      function updateUI() {
        scoreDisplay.textContent = score;
        coinsDisplay.textContent = coinsCollected;
        speedDisplay.textContent = scrollSpeed.toFixed(1);
      }

      function showGameOver() {
        gameOver = true;
        isPlaying = false;
        finalScore.textContent = score;
        finalCoins.textContent = coinsCollected;
        gameOverOverlay.classList.add('show');
        playPauseBtn.innerHTML = '‚ñ∂Ô∏è START GAME';
        gameAudio.play('death');
      }

      window.restartGame = function() {
        offsetY = 0;
        score = 0;
        coinsCollected = 0;
        scrollSpeed = SCROLL_SPEED_MIN;
        gameOver = false;
        isPlaying = false;
        player.side = 'left';
        player.x = getWallXLeft();
        player.y = getPlayerY();
        player.animFrame = 0;
        player.jumpAnimation = 0;
        initObstacles();
        initCoins();
        gameOverOverlay.classList.remove('show');
        playPauseBtn.innerHTML = '‚ñ∂Ô∏è START GAME';
        updateUI();
      };

      // Event listeners
      window.addEventListener('keydown', e => {
        if (e.code === 'Space') {
          e.preventDefault();
          gameAudio.resume();
          if (gameOver) restartGame();
          else jump();
        }
      });

      window.addEventListener('mousedown', () => {
        gameAudio.resume();
        if (gameOver) restartGame();
        else jump();
      });

      window.addEventListener('touchstart', e => {
        e.preventDefault();
        gameAudio.resume();
        if (gameOver) restartGame();
        else jump();
      }, { passive: false });

      playPauseBtn.addEventListener('click', () => {
        gameAudio.resume();
        if (gameOver) {
          restartGame();
          isPlaying = true;
          playPauseBtn.innerHTML = '‚è∏Ô∏è PAUSE';
          return;
        }
        isPlaying = !isPlaying;
        playPauseBtn.innerHTML = isPlaying ? '‚è∏Ô∏è PAUSE' : '‚ñ∂Ô∏è RESUME';
      });

      function checkCollision() {
        const playerSize = getPlayerSize();
        const obstacleSize = getObstacleSize();
        
        if (lavaTop() <= player.y + playerSize) {
          showGameOver();
          return;
        }
        
        for (const obs of obstacles) {
          const obsScreenY = obs.y + offsetY;
          if (obsScreenY > H() || obsScreenY < 0) continue;
          if (obs.side === player.side) {
            if (
              player.y + playerSize > obsScreenY - obstacleSize &&
              player.y < obsScreenY + obstacleSize / 2
            ) {
              showGameOver();
              return;
            }
          }
        }

        for (const coin of coins) {
          if (coin.collected) continue;
          const coinY = coin.y + offsetY;
          if (coin.side === player.side) {
            const dx = player.x - (coin.side === 'left' ? getWallXLeft() : getWallXRight());
            const dy = player.y - coinY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < playerSize) {
              coin.collected = true;
              coinsCollected++;
              score += 5;
              scrollSpeed = Math.min(SCROLL_SPEED_MAX, scrollSpeed + SPEED_INCREASE_RATE * 100);
              gameAudio.play('collect');
            }
          }
        }
      }

      function update(delta) {
        if (gameOver || !isPlaying) return;

        const spacing = getObstacleSpacing();
        offsetY += scrollSpeed * (delta / 16);
        score = Math.floor(offsetY / 10) + coinsCollected * 5;
        scrollSpeed = Math.min(SCROLL_SPEED_MAX, SCROLL_SPEED_MIN + SPEED_INCREASE_RATE * score);

        // Update player animation
        player.animFrame = (player.animFrame + 0.2) % (Math.PI * 2);
        if (player.jumpAnimation > 0) player.jumpAnimation--;

        for (let obs of obstacles) {
          if (obs.y + offsetY > H() + 40) {
            obs.y -= obstacleCount * spacing;
            obs.side = (Math.random() > 0.5) ? 'left' : 'right';
            obs.type = Math.floor(Math.random() * 3);
          }
        }

        for (let coin of coins) {
          if (coin.y + offsetY > H() + 40) {
            coin.y -= obstacleCount * spacing;
            coin.collected = false;
            for (let i = 0; i < 10; i++) {
              const side = (Math.random() > 0.5) ? 'left' : 'right';
              if (isSafePosition(side, coin.y)) {
                coin.side = side;
                break;
              }
            }
          }
        }

        updateUI();
        checkCollision();
      }

      // Enhanced drawing functions
      function drawWall(x) {
        const wallWidth = W() * 0.04;
        const gradient = ctx.createLinearGradient(x - wallWidth/2, 0, x + wallWidth/2, 0);
        gradient.addColorStop(0, '#2a2a2a');
        gradient.addColorStop(0.5, '#4a4a4a');
        gradient.addColorStop(1, '#2a2a2a');
        ctx.fillStyle = gradient;
        ctx.fillRect(x - wallWidth/2, 0, wallWidth, H());
        
        // Add bamboo texture
        ctx.fillStyle = 'rgba(139, 69, 19, 0.6)';
        const textureSpacing = H() * 0.07;
        for (let i = 0; i < H(); i += textureSpacing) {
          ctx.fillRect(x - wallWidth/2 + 2, i, wallWidth - 4, 3);
          ctx.fillRect(x - wallWidth/4, i + textureSpacing/2, wallWidth/2, 2);
        }
      }

      function drawNinja() {
        const x = player.x;
        const y = player.y;
        const playerSize = getPlayerSize();
        const jumpOffset = player.jumpAnimation > 0 ? Math.sin(player.jumpAnimation / 3) * 3 : 0;
        const bobOffset = Math.sin(player.animFrame) * 1;
        
        ctx.save();
        ctx.translate(x, y - jumpOffset + bobOffset);
        
        // Ninja shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.fillRect(-playerSize/2 + 1, playerSize/2 + 1, playerSize, 4);
        
        // Ninja body (dark blue/black)
        ctx.fillStyle = '#1a1a2e';
        ctx.fillRect(-playerSize/2, -playerSize/2, playerSize, playerSize);
        
        // Ninja mask/head
        ctx.fillStyle = '#16213e';
        ctx.fillRect(-playerSize/2 + 2, -playerSize/2 + 2, playerSize - 4, playerSize/2);
        
        // Ninja eyes (glowing)
        ctx.fillStyle = '#ff4444';
        ctx.fillRect(-playerSize/2 + 4, -playerSize/2 + 6, 3, 2);
        ctx.fillRect(-playerSize/2 + 9, -playerSize/2 + 6, 3, 2);
        
        // Ninja belt
        ctx.fillStyle = '#8B4513';
        ctx.fillRect(-playerSize/2, -2, playerSize, 3);
        
        // Ninja weapon (katana outline)
        if (player.jumpAnimation > 0) {
          ctx.strokeStyle = '#C0C0C0';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(playerSize/2, -playerSize/2);
          ctx.lineTo(playerSize/2 + 8, -playerSize/2 - 8);
          ctx.stroke();
        }
        
        // Movement blur effect during jump
        if (player.jumpAnimation > 0) {
          ctx.fillStyle = 'rgba(26, 26, 46, 0.3)';
          ctx.fillRect(-playerSize/2 - 3, -playerSize/2, playerSize, playerSize);
        }
        
        ctx.restore();
      }

      function drawLava() {
        const y = lavaTop();
        const gradient = ctx.createLinearGradient(0, y, 0, H());
        gradient.addColorStop(0, '#ff6600');
        gradient.addColorStop(0.3, '#ff3300');
        gradient.addColorStop(0.7, '#cc0000');
        gradient.addColorStop(1, '#990000');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, y, W(), H() - y);
        
        // Lava bubbles effect
        ctx.fillStyle = 'rgba(255, 255, 0, 0.6)';
        for (let i = 0; i < 10; i++) {
          const bubbleX = (i * W() / 10) + Math.sin(Date.now() * 0.01 + i) * 12;
          const bubbleY = y + 12 + Math.sin(Date.now() * 0.008 + i * 2) * 8;
          ctx.beginPath();
          ctx.arc(bubbleX, bubbleY, 3 + Math.sin(Date.now() * 0.01 + i) * 2, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      function drawObstacles() {
        const obstacleSize = getObstacleSize();
        obstacles.forEach(obs => {
          const y = obs.y + offsetY;
          if (y < -obstacleSize || y > H() + obstacleSize) return;
          
          const x = obs.side === 'left' ? getWallXLeft() : getWallXRight();
          const rotation = Date.now() * 0.01;
          
          ctx.save();
          ctx.translate(x, y);
          
          switch(obs.type) {
            case 0: // Spinning Shuriken
              ctx.rotate(rotation * 2);
              ctx.fillStyle = '#C0C0C0';
              ctx.beginPath();
              for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const radius = i % 2 === 0 ? obstacleSize : obstacleSize / 2;
                const px = Math.cos(angle) * radius;
                const py = Math.sin(angle) * radius;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
              }
              ctx.closePath();
              ctx.fill();
              // Add shine
              ctx.fillStyle = '#FFFFFF';
              ctx.fillRect(-2, -1, 4, 2);
              break;
              
            case 1: // Kunai Knife
              ctx.rotate(Math.PI / 4);
              // Blade
              ctx.fillStyle = '#C0C0C0';
              ctx.fillRect(-2, -obstacleSize, 4, obstacleSize);
              // Handle
              ctx.fillStyle = '#8B4513';
              ctx.fillRect(-3, 0, 6, obstacleSize/2);
              // Tip
              ctx.fillStyle = '#C0C0C0';
              ctx.beginPath();
              ctx.moveTo(0, -obstacleSize);
              ctx.lineTo(-2, -obstacleSize + 4);
              ctx.lineTo(2, -obstacleSize + 4);
              ctx.closePath();
              ctx.fill();
              break;
              
            case 2: // Fire Trap
              const flameHeight = obstacleSize + Math.sin(rotation * 3) * 4;
              // Base
              ctx.fillStyle = '#8B4513';
              ctx.fillRect(-obstacleSize/2, obstacleSize/2 - 3, obstacleSize, 6);
              // Flame
              const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, flameHeight);
              gradient.addColorStop(0, '#ffff00');
              gradient.addColorStop(0.5, '#ff6600');
              gradient.addColorStop(1, '#ff0000');
              ctx.fillStyle = gradient;
              ctx.beginPath();
              ctx.ellipse(0, 0, obstacleSize/3, flameHeight/2, 0, 0, Math.PI * 2);
              ctx.fill();
              break;
          }
          
          ctx.restore();
        });
      }

      function drawCoins() {
        const coinSize = getCoinSize();
        coins.forEach(coin => {
          if (coin.collected) return;
          const y = coin.y + offsetY;
          if (y < -coinSize || y > H() + coinSize) return;
          const x = coin.side === 'left' ? getWallXLeft() : getWallXRight();
          
          // Coin rotation effect
          const rotation = (Date.now() * 0.01) % (Math.PI * 2);
          const scale = 0.8 + Math.sin(Date.now() * 0.01) * 0.2;
          
          ctx.save();
          ctx.translate(x, y);
          ctx.scale(scale, 1);
          ctx.rotate(rotation);
          
          // Coin glow
          ctx.shadowColor = '#ffd700';
          ctx.shadowBlur = 8;
          
          // Main coin
          const coinGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, coinSize / 2);
          coinGradient.addColorStop(0, '#ffed4e');
          coinGradient.addColorStop(0.7, '#ffd700');
          coinGradient.addColorStop(1, '#b8860b');
          ctx.fillStyle = coinGradient;
          ctx.beginPath();
          ctx.arc(0, 0, coinSize / 2, 0, Math.PI * 2);
          ctx.fill();
          
          // Coin inner design (ninja symbol)
          ctx.shadowBlur = 0;
          ctx.fillStyle = '#8B4513';
          ctx.beginPath();
          ctx.arc(0, 0, coinSize / 4, 0, Math.PI * 2);
          ctx.fill();
          
          // Highlight
          ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
          ctx.beginPath();
          ctx.arc(-2, -2, coinSize / 6, 0, Math.PI * 2);
          ctx.fill();
          
          ctx.restore();
        });
      }

      function gameLoop(time = 0) {
        const delta = time - lastTime;
        lastTime = time;

        ctx.clearRect(0, 0, W(), H());

        drawWall(getWallXLeft());
        drawWall(getWallXRight());
        drawObstacles();
        drawCoins();
        drawNinja();
        drawLava();

        if (isPlaying && !gameOver) {
          update(delta);
        }

        requestAnimationFrame(gameLoop);
      }

      // Initialize game
      function initGame() {
        createParticles();
        restartGame();
        requestAnimationFrame(gameLoop);
      }

      // Start the game when page loads
      initGame();
    })();
  </script>
</body>
</html>

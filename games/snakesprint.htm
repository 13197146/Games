<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <!-- SEO Meta Tags -->
  <title>Snake Sprint - Modern Snake Game | Play Free Online</title>
  <meta name="description" content="Play Snake Sprint, the modern twist on classic Snake! Control with arrow keys or swipe gestures. Beautiful capsule design, smooth animations, and addictive gameplay.">
  <meta name="keywords" content="snake game, snake sprint, online game, free game, mobile game, classic arcade, retro game, browser game">
  <meta name="author" content="Snake Sprint Game">
  <meta name="robots" content="index, follow">
  <meta name="theme-color" content="#6366f1">
  
  <!-- Open Graph Meta Tags -->
  <meta property="og:title" content="Snake Sprint - Modern Snake Game">
  <meta property="og:description" content="Experience the classic Snake game with a modern twist! Smooth controls, beautiful graphics, and addictive gameplay.">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://example.com/snake-sprint">
  <meta property="og:image" content="https://example.com/snake-sprint-preview.jpg">
  <meta property="og:site_name" content="Snake Sprint">
  
  <!-- Twitter Card Meta Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Snake Sprint - Modern Snake Game">
  <meta name="twitter:description" content="Experience the classic Snake game with a modern twist!">
  <meta name="twitter:image" content="https://example.com/snake-sprint-preview.jpg">
  <meta name="twitter:creator" content="@snakesprintgame">
  
  <!-- Favicon -->
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üêç</text></svg>">
  <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üêç</text></svg>">
  
  <!-- Schema.org JSON-LD -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "VideoGame",
    "name": "Snake Sprint",
    "description": "A modern version of the classic Snake game with smooth controls and beautiful graphics. Control the snake to eat food while avoiding obstacles and walls.",
    "genre": ["Arcade", "Casual", "Retro"],
    "playMode": "SinglePlayer",
    "applicationCategory": "Game",
    "operatingSystem": "Web Browser",
    "gamePlatform": ["Web Browser", "Mobile", "Desktop"],
    "controlScheme": ["Keyboard", "Touch"],
    "offers": {
      "@type": "Offer",
      "price": "0",
      "priceCurrency": "USD"
    },
    "aggregateRating": {
      "@type": "AggregateRating",
      "ratingValue": "4.8",
      "ratingCount": "1250"
    }
  }
  </script>

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&display=swap');
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --primary: #6366f1;
      --primary-dark: #4f46e5;
      --secondary: #10b981;
      --danger: #ef4444;
      --warning: #f59e0b;
      --background: #0f0f23;
      --surface: #1a1a2e;
      --surface-light: #16213e;
      --text-primary: #ffffff;
      --text-secondary: #a1a1aa;
      --accent: #8b5cf6;
      --glow: rgba(99, 102, 241, 0.4);
      --snake-head: #22c55e;
      --snake-body: #16a34a;
      --food: #f97316;
      --obstacle: #64748b;
    }

    body {
      margin: 0;
      background: linear-gradient(135deg, var(--background) 0%, #1a1a2e 50%, #16213e 100%);
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      color: var(--text-primary);
      font-family: 'Inter', sans-serif;
      user-select: none;
      overflow-x: hidden;
      position: relative;
    }

    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: radial-gradient(circle at 20% 80%, rgba(99, 102, 241, 0.1) 0%, transparent 50%),
                  radial-gradient(circle at 80% 20%, rgba(139, 92, 246, 0.1) 0%, transparent 50%),
                  radial-gradient(circle at 40% 40%, rgba(16, 185, 129, 0.05) 0%, transparent 50%);
      pointer-events: none;
      z-index: -1;
    }

    .game-header {
      text-align: center;
      padding: 2rem 1rem 1rem;
      max-width: 600px;
    }

    .game-title {
      font-size: clamp(2.5rem, 6vw, 4rem);
      font-weight: 800;
      background: linear-gradient(135deg, var(--primary), var(--accent), var(--secondary));
      background-size: 200% 200%;
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: gradientShift 4s ease-in-out infinite;
      margin-bottom: 0.5rem;
      letter-spacing: -0.02em;
    }

    .game-subtitle {
      font-size: 1.1rem;
      color: var(--text-secondary);
      font-weight: 400;
      margin-bottom: 1rem;
    }

    @keyframes gradientShift {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }

    .game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 2rem;
      padding: 0 1rem;
      width: 100%;
      max-width: 800px;
    }

    .game-board-container {
      position: relative;
      padding: 1.5rem;
      background: linear-gradient(145deg, var(--surface), var(--surface-light));
      border-radius: 2rem;
      box-shadow: 
        0 20px 40px rgba(0, 0, 0, 0.4),
        0 0 0 1px rgba(255, 255, 255, 0.05),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(20px);
    }

    canvas {
      background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
      border-radius: 1.5rem;
      box-shadow: 
        inset 0 2px 10px rgba(0, 0, 0, 0.3),
        0 0 20px rgba(99, 102, 241, 0.2);
      image-rendering: pixelated;
      display: block;
    }

    .game-ui {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 100%;
      max-width: 500px;
      gap: 1rem;
      flex-wrap: wrap;
    }

    .stat-card {
      background: linear-gradient(145deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 1rem;
      padding: 1rem 1.5rem;
      text-align: center;
      flex: 1;
      min-width: 100px;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .stat-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 30px rgba(99, 102, 241, 0.2);
      border-color: rgba(99, 102, 241, 0.3);
    }

    .stat-label {
      font-size: 0.8rem;
      color: var(--text-secondary);
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 0.25rem;
    }

    .stat-value {
      font-size: 1.8rem;
      font-weight: 700;
      color: var(--text-primary);
      font-family: 'JetBrains Mono', monospace;
    }

    .controls {
      display: flex;
      gap: 1rem;
      align-items: center;
      flex-wrap: wrap;
      justify-content: center;
    }

    .btn {
      background: linear-gradient(145deg, var(--primary), var(--primary-dark));
      border: none;
      color: white;
      padding: 0.75rem 1.5rem;
      font-family: 'Inter', sans-serif;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      border-radius: 50px;
      box-shadow: 
        0 4px 15px rgba(99, 102, 241, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.2);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      overflow: hidden;
      min-width: 120px;
    }

    .btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      transition: left 0.6s;
    }

    .btn:hover::before {
      left: 100%;
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 
        0 8px 25px rgba(99, 102, 241, 0.5),
        inset 0 1px 0 rgba(255, 255, 255, 0.3);
    }

    .btn:active {
      transform: translateY(0);
    }

    .instructions {
      background: linear-gradient(145deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.04));
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 1.5rem;
      padding: 1.5rem 2rem;
      text-align: center;
      max-width: 500px;
      width: 100%;
    }

    .instructions h3 {
      font-size: 1.3rem;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 1rem;
    }

    .instructions p {
      color: var(--text-secondary);
      line-height: 1.6;
      margin-bottom: 1rem;
    }

    .control-keys {
      display: flex;
      gap: 0.5rem;
      justify-content: center;
      flex-wrap: wrap;
    }

    .key {
      background: linear-gradient(145deg, #374151, #4b5563);
      color: white;
      padding: 0.5rem 0.75rem;
      border-radius: 0.5rem;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.9rem;
      font-weight: 500;
      box-shadow: 
        0 2px 5px rgba(0, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }

    .high-scores {
      background: linear-gradient(145deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.04));
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 1.5rem;
      padding: 1.5rem 2rem;
      width: 100%;
      max-width: 400px;
    }

    .high-scores h2 {
      font-size: 1.3rem;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 1rem;
      text-align: center;
    }

    .high-scores ol {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    .high-scores li {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem 1rem;
      margin-bottom: 0.5rem;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 0.75rem;
      font-family: 'JetBrains Mono', monospace;
      position: relative;
    }

    .high-scores li::before {
      content: counter(item);
      counter-increment: item;
      background: var(--primary);
      color: white;
      font-size: 0.8rem;
      font-weight: 600;
      padding: 0.25rem 0.5rem;
      border-radius: 50px;
      min-width: 1.5rem;
      text-align: center;
      margin-right: 1rem;
    }

    .high-scores ol {
      counter-reset: item;
    }

    .game-message {
      text-align: center;
      font-size: 1.1rem;
      font-weight: 500;
      padding: 1rem;
      border-radius: 1rem;
      margin: 1rem 0;
      min-height: 3rem;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
    }

    .game-message.error {
      background: linear-gradient(145deg, rgba(239, 68, 68, 0.15), rgba(239, 68, 68, 0.1));
      border: 1px solid rgba(239, 68, 68, 0.3);
      color: #fca5a5;
    }

    .game-message.success {
      background: linear-gradient(145deg, rgba(16, 185, 129, 0.15), rgba(16, 185, 129, 0.1));
      border: 1px solid rgba(16, 185, 129, 0.3);
      color: #6ee7b7;
    }

    /* Mobile Responsive */
    @media (max-width: 768px) {
      .game-header {
        padding: 1rem;
      }

      .game-container {
        gap: 1.5rem;
      }

      .game-board-container {
        padding: 1rem;
      }

      .game-ui {
        max-width: 100%;
      }

      .stat-card {
        padding: 0.75rem 1rem;
        min-width: 80px;
      }

      .stat-value {
        font-size: 1.5rem;
      }

      .instructions {
        padding: 1rem 1.5rem;
      }

      .btn {
        padding: 0.6rem 1.2rem;
        font-size: 0.9rem;
        min-width: 100px;
      }
    }

    @media (max-width: 480px) {
      canvas {
        width: 90vw !important;
        height: 90vw !important;
        max-width: 350px;
        max-height: 350px;
      }

      .game-ui {
        flex-direction: column;
        gap: 0.5rem;
      }

      .controls {
        width: 100%;
      }

      .btn {
        flex: 1;
        min-width: 0;
      }
    }

    /* Animations */
    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }

    @keyframes bounce {
      0%, 20%, 53%, 80%, 100% { transform: translateY(0); }
      40%, 43% { transform: translateY(-10px); }
      70% { transform: translateY(-5px); }
      90% { transform: translateY(-2px); }
    }

    .pulse {
      animation: pulse 2s infinite;
    }

    .bounce {
      animation: bounce 2s infinite;
    }

    /* Loading states */
    .loading {
      opacity: 0.7;
      pointer-events: none;
    }

    .loading .btn {
      background: linear-gradient(145deg, #6b7280, #9ca3af);
      cursor: not-allowed;
    }
  </style>
</head>
<body>
  <div class="game-header">
    <h1 class="game-title">üêç Snake Sprint</h1>
    <p class="game-subtitle">Classic Snake Game with Modern Style</p>
  </div>

  <div class="game-container">
    <div class="game-ui">
      <div class="stat-card">
        <div class="stat-label">Score</div>
        <div class="stat-value" id="score">0</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Length</div>
        <div class="stat-value" id="length">1</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Level</div>
        <div class="stat-value" id="level">1</div>
      </div>
    </div>

    <div class="game-board-container">
      <canvas id="game" width="400" height="400"></canvas>
    </div>

    <div class="game-message" id="gameMessage"></div>

    <div class="controls">
      <button class="btn" id="playPauseBtn">üéÆ Start Game</button>
      <button class="btn" id="resetBtn">üîÑ Reset</button>
    </div>

    <div class="instructions">
      <h3>üéØ How to Play</h3>
      <p>Control your snake to eat food and grow longer! Avoid hitting walls, obstacles, or yourself. Food disappears after 12 seconds, so be quick!</p>
      <div class="control-keys">
        <span class="key">‚Üë ‚Üì ‚Üê ‚Üí</span>
        <span class="key">WASD</span>
        <span class="key">Swipe</span>
        <span class="key">Space</span>
      </div>
    </div>

    <div class="high-scores">
      <h2>üèÜ High Scores</h2>
      <ol id="highScoresList">
        <li><span>No scores yet</span></li>
      </ol>
    </div>
  </div>

  <script>
    (() => {
      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');
      const scoreEl = document.getElementById('score');
      const lengthEl = document.getElementById('length');
      const levelEl = document.getElementById('level');
      const highScoresList = document.getElementById('highScoresList');
      const gameMessage = document.getElementById('gameMessage');
      const playPauseBtn = document.getElementById('playPauseBtn');
      const resetBtn = document.getElementById('resetBtn');

      // Responsive canvas sizing
      function resizeCanvas() {
        const container = canvas.parentElement;
        const maxSize = Math.min(window.innerWidth - 40, 400);
        canvas.style.width = maxSize + 'px';
        canvas.style.height = maxSize + 'px';
      }

      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);

      const CELL_SIZE = 20;
      const COLS = canvas.width / CELL_SIZE;
      const ROWS = canvas.height / CELL_SIZE;

      // Directions as vectors
      const DIRS = {
        right: { x: 1, y: 0 },
        down: { x: 0, y: 1 },
        left: { x: -1, y: 0 },
        up: { x: 0, y: -1 },
      };

      // Game variables
      let snake, direction, food, obstacles, score, foodTimer, level;
      const FOOD_LIFETIME = 12000;
      const BASE_OBSTACLE_COUNT = 5;
      const BASE_FPS = 6;
      let gameInterval = null;
      let isPaused = true;
      let gameStarted = false;

      // High score tracking
      let highScores = JSON.parse(localStorage.getItem('snakeHighScores') || '[]');

      function reset() {
        snake = [{ x: Math.floor(COLS / 2), y: Math.floor(ROWS / 2) }];
        direction = DIRS.right;
        score = 0;
        level = 1;
        updateUI();
        generateObstacles();
        placeFood();
        clearMessage();
      }

      function generateObstacles() {
        obstacles = [];
        const obstacleCount = Math.min(BASE_OBSTACLE_COUNT + Math.floor(level / 2), 12);
        
        while (obstacles.length < obstacleCount) {
          const pos = { x: randInt(0, COLS - 1), y: randInt(0, ROWS - 1) };
          if (
            snake.some((s) => s.x === pos.x && s.y === pos.y) ||
            obstacles.some((o) => o.x === pos.x && o.y === pos.y)
          ) continue;
          obstacles.push(pos);
        }
      }

      function placeFood() {
        let tries = 0;
        do {
          food = { x: randInt(0, COLS - 1), y: randInt(0, ROWS - 1) };
          tries++;
          if (tries > 100) break;
        } while (
          snake.some((s) => s.x === food.x && s.y === food.y) ||
          obstacles.some((o) => o.x === food.x && o.y === food.y)
        );
        foodTimer = Date.now();
      }

      function randInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
      }

      function drawCapsule(x, y, color, glowColor = null) {
        const centerX = x * CELL_SIZE + CELL_SIZE / 2;
        const centerY = y * CELL_SIZE + CELL_SIZE / 2;
        const radius = CELL_SIZE / 2 - 2;

        ctx.save();
        
        if (glowColor) {
          ctx.shadowColor = glowColor;
          ctx.shadowBlur = 10;
        }

        const gradient = ctx.createRadialGradient(
          centerX - radius/3, centerY - radius/3, 0,
          centerX, centerY, radius
        );
        gradient.addColorStop(0, lightenColor(color, 20));
        gradient.addColorStop(1, color);
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
        ctx.fill();

        // Add highlight
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.beginPath();
        ctx.arc(centerX - radius/3, centerY - radius/3, radius/3, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
      }

      function lightenColor(color, percent) {
        const num = parseInt(color.replace("#",""), 16);
        const amt = Math.round(2.55 * percent);
        const R = (num >> 16) + amt;
        const G = (num >> 8 & 0x00FF) + amt;
        const B = (num & 0x0000FF) + amt;
        return "#" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
          (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
          (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw obstacles
        obstacles.forEach(o => {
          drawCapsule(o.x, o.y, '#64748b');
        });

        // Draw food with blink effect
        const timeLeft = FOOD_LIFETIME - (Date.now() - foodTimer);
        if (timeLeft > 0) {
          if (timeLeft < 3000 && Math.floor(Date.now() / 300) % 2 === 0) {
            // Blink effect
          } else {
            drawCapsule(food.x, food.y, '#f97316', '#fb923c');
          }
        }

        // Draw snake
        snake.forEach((segment, i) => {
          const isHead = i === snake.length - 1;
          const color = isHead ? '#22c55e' : '#16a34a';
          const glowColor = isHead ? '#4ade80' : null;
          drawCapsule(segment.x, segment.y, color, glowColor);
        });
      }

      function update() {
        const head = snake[snake.length - 1];
        const newHead = { x: head.x + direction.x, y: head.y + direction.y };

        // Check collisions
        if (
          newHead.x < 0 || newHead.x >= COLS ||
          newHead.y < 0 || newHead.y >= ROWS ||
          snake.some((s) => s.x === newHead.x && s.y === newHead.y) ||
          obstacles.some((o) => o.x === newHead.x && o.y === newHead.y)
        ) {
          gameOver();
          return;
        }

        snake.push(newHead);

        // Check if ate food
        if (
          food && newHead.x === food.x && newHead.y === food.y &&
          Date.now() - foodTimer <= FOOD_LIFETIME
        ) {
          score += 10;
          level = Math.floor(score / 50) + 1;
          placeFood();
          
          // Level up effects
          if ((score % 50) === 0 && score > 0) {
            showMessage('Level Up! üéâ', 'success');
            generateObstacles();
          }
        } else {
          snake.shift();
        }

        // Food expired
        if (food && Date.now() - foodTimer > FOOD_LIFETIME) {
          placeFood();
        }

        updateUI();
      }

      function setDirection(newDir) {
        if (direction.x + newDir.x === 0 && direction.y + newDir.y === 0) return;
        direction = newDir;
      }

      function gameOver() {
        pauseGame();
        showMessage(`Game Over! Final Score: ${score} üíÄ`, 'error');
        addHighScore(score);
        setTimeout(() => {
          reset();
          draw();
        }, 2000);
      }

      function addHighScore(score) {
        if (score > 0) {
          highScores.push(score);
          highScores.sort((a, b) => b - a);
          highScores = highScores.slice(0, 5);
          localStorage.setItem('snakeHighScores', JSON.stringify(highScores));
          updateHighScoresUI();
        }
      }

      function updateHighScoresUI() {
        if (highScores.length === 0) {
          highScoresList.innerHTML = '<li><span>No scores yet</span></li>';
        } else {
          highScoresList.innerHTML = highScores
            .map(s => `<li><span>${s}</span></li>`)
            .join('');
        }
      }

      function updateUI() {
        scoreEl.textContent = score;
        lengthEl.textContent = snake.length;
        levelEl.textContent = level;
      }

      function showMessage(text, type = '') {
        gameMessage.textContent = text;
        gameMessage.className = `game-message ${type}`;
        setTimeout(clearMessage, 3000);
      }

      function clearMessage() {
        gameMessage.textContent = '';
        gameMessage.className = 'game-message';
      }

      function loop() {
        update();
        draw();
      }

      function playGame() {
        if (!gameInterval) {
          const fps = Math.min(BASE_FPS + Math.floor(level / 3), 12);
          gameInterval = setInterval(loop, 1000 / fps);
          isPaused = false;
          gameStarted = true;
          playPauseBtn.innerHTML = '‚è∏Ô∏è Pause';
          clearMessage();
        }
      }

      function pauseGame() {
        if (gameInterval) {
          clearInterval(gameInterval);
          gameInterval = null;
          isPaused = true;
          playPauseBtn.innerHTML = gameStarted ? '‚ñ∂Ô∏è Resume' : 'üéÆ Start Game';
        }
      }

      function togglePause() {
        if (isPaused) {
          playGame();
        } else {
          pauseGame();
        }
      }

      function resetGame() {
        pauseGame();
        gameStarted = false;
        reset();
        draw();
        playPauseBtn.innerHTML = 'üéÆ Start Game';
        showMessage('Game Reset! Ready to play? üöÄ', 'success');
      }

      // Keyboard controls
      window.addEventListener('keydown', (e) => {
        switch (e.code) {
          case 'ArrowUp':
          case 'KeyW':
            e.preventDefault();
            setDirection(DIRS.up);
            if (!gameStarted) togglePause();
            break;
          case 'ArrowDown':
          case 'KeyS':
            e.preventDefault();
            setDirection(DIRS.down);
            if (!gameStarted) togglePause();
            break;
          case 'ArrowLeft':
          case 'KeyA':
            e.preventDefault();
            setDirection(DIRS.left);
            if (!gameStarted) togglePause();
            break;
          case 'ArrowRight':
          case 'KeyD':
            e.preventDefault();
            setDirection(DIRS.right);
            if (!gameStarted) togglePause();
            break;
          case 'Space':
            e.preventDefault();
            togglePause();
            break;
        }
      });

      // Touch controls for mobile
      let touchStartX = null;
      let touchStartY = null;
      const MIN_SWIPE_DISTANCE = 30;

      canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (e.touches.length === 1) {
          touchStartX = e.touches[0].clientX;
          touchStartY = e.touches[0].clientY;
        }
      }, { passive: false });

      canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        if (!touchStartX || !touchStartY) return;

        const touchEndX = e.touches[0].clientX;
        const touchEndY = e.touches[0].clientY;

        const dx = touchEndX - touchStartX;
        const dy = touchEndY - touchStartY;

        if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > MIN_SWIPE_DISTANCE) {
          if (dx > 0) {
            setDirection(DIRS.right);
          } else {
            setDirection(DIRS.left);
          }
          if (!gameStarted) togglePause();
          touchStartX = null;
          touchStartY = null;
        } else if (Math.abs(dy) > MIN_SWIPE_DISTANCE) {
          if (dy > 0) {
            setDirection(DIRS.down);
          } else {
            setDirection(DIRS.up);
          }
          if (!gameStarted) togglePause();
          touchStartX = null;
          touchStartY = null;
        }
      }, { passive: false });

      canvas.addEventListener('touchend', (e) => {
        e.preventDefault();
        touchStartX = null;
        touchStartY = null;
      }, { passive: false });

      // Button event listeners
      playPauseBtn.addEventListener('click', togglePause);
      resetBtn.addEventListener('click', resetGame);

      // Canvas click to start (for desktop)
      canvas.addEventListener('click', () => {
        if (!gameStarted) {
          togglePause();
        }
      });

      // Prevent context menu on long press
      canvas.addEventListener('contextmenu', (e) => {
        e.preventDefault();
      });

      // Visibility API - pause when tab becomes inactive
      document.addEventListener('visibilitychange', () => {
        if (document.hidden && !isPaused && gameStarted) {
          pauseGame();
          showMessage('Game Paused - Tab Inactive ‚è∏Ô∏è');
        }
      });

      // Initialize game
      updateHighScoresUI();
      reset();
      draw();
      showMessage('Welcome to Snake Sprint! üêç‚ú®', 'success');

      // Add some startup animations
      setTimeout(() => {
        const statCards = document.querySelectorAll('.stat-card');
        statCards.forEach((card, index) => {
          setTimeout(() => {
            card.style.animation = 'bounce 0.6s ease-out';
          }, index * 100);
        });
      }, 500);

      // Performance optimization - reduce draw calls when paused
      let lastDrawTime = 0;
      const originalDraw = draw;
      draw = function() {
        const now = Date.now();
        if (isPaused && now - lastDrawTime < 100) return; // Limit redraws when paused
        lastDrawTime = now;
        originalDraw();
      };

      // Add easter egg - Konami code
      let konamiCode = [];
      const konami = [
        'ArrowUp', 'ArrowUp', 'ArrowDown', 'ArrowDown',
        'ArrowLeft', 'ArrowRight', 'ArrowLeft', 'ArrowRight'
      ];

      window.addEventListener('keydown', (e) => {
        konamiCode.push(e.code);
        if (konamiCode.length > konami.length) {
          konamiCode.shift();
        }
        
        if (konamiCode.length === konami.length && 
            konamiCode.every((code, i) => code === konami[i])) {
          showMessage('üéâ Konami Code Activated! Bonus Speed! üöÄ', 'success');
          // Easter egg effect - temporarily increase speed
          if (gameInterval) {
            clearInterval(gameInterval);
            gameInterval = setInterval(loop, 1000 / (BASE_FPS * 2));
            setTimeout(() => {
              if (gameInterval) {
                clearInterval(gameInterval);
                const fps = Math.min(BASE_FPS + Math.floor(level / 3), 12);
                gameInterval = setInterval(loop, 1000 / fps);
              }
            }, 5000);
          }
          konamiCode = [];
        }
      });

      // Add particle effects for special events
      function createParticles(x, y, color, count = 10) {
        const particles = [];
        for (let i = 0; i < count; i++) {
          particles.push({
            x: x + Math.random() * 20 - 10,
            y: y + Math.random() * 20 - 10,
            vx: Math.random() * 4 - 2,
            vy: Math.random() * 4 - 2,
            life: 1,
            color: color
          });
        }
        
        const animateParticles = () => {
          particles.forEach((p, index) => {
            p.x += p.vx;
            p.y += p.vy;
            p.life -= 0.02;
            p.vy += 0.1; // gravity
            
            if (p.life <= 0) {
              particles.splice(index, 1);
            }
          });
          
          if (particles.length > 0) {
            requestAnimationFrame(animateParticles);
          }
        };
        
        animateParticles();
      }

      // Enhanced food collection with particles
      const originalUpdate = update;
      update = function() {
        const head = snake[snake.length - 1];
        const newHead = { x: head.x + direction.x, y: head.y + direction.y };
        
        // Store food position for particle effect
        const foodEaten = food && newHead.x === food.x && newHead.y === food.y &&
                          Date.now() - foodTimer <= FOOD_LIFETIME;
        
        originalUpdate();
        
        // Create particles when food is eaten
        if (foodEaten) {
          const centerX = food.x * CELL_SIZE + CELL_SIZE / 2;
          const centerY = food.y * CELL_SIZE + CELL_SIZE / 2;
          createParticles(centerX, centerY, '#f97316', 8);
        }
      };

    })();
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
<title>Lane Hopper - Swipe + Keyboard</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    background: #111;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    color: white;
    height: 100%;
    width: 100%;
    user-select: none;
    touch-action: manipulation;
    -webkit-tap-highlight-color: transparent;
    overflow: hidden;
  }

  #game {
    position: relative;
    width: 100vw;
    max-width: 310px;
    height: 100vh;
    max-height: 700px;
    background: #222;
    border: 3px solid #555;
    border-radius: 12px;
    margin: auto;
    overflow: hidden;
    touch-action: pan-y;
  }

  .player-car, .obstacle {
    position: absolute;
    width: 30px;
    height: 50px;
    border-radius: 8px;
  }

  .player-car {
    bottom: 20px;
    transition: left 0.15s ease;
  }

  .obstacle {
    top: -70px;
  }

  #scoreboard {
    position: absolute;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    font-weight: bold;
    font-size: 18px;
    z-index: 2;
  }

  #bestscore {
    position: absolute;
    top: 35px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 12px;
    color: #bbb;
    z-index: 2;
  }

  #taphint {
    position: absolute;
    bottom: 10px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 14px;
    opacity: 0.5;
    z-index: 2;
  }

  #playPauseBtn {
    position: absolute;
    top: 10px;
    right: 10px;
    z-index: 3;
    background: #444;
    border: none;
    color: white;
    padding: 6px 10px;
    border-radius: 6px;
    font-weight: bold;
    cursor: pointer;
    user-select: none;
    font-size: 14px;
    transition: background 0.3s;
  }

  #playPauseBtn:hover {
    background: #666;
  }
</style>
</head>
<body>
<div id="game" tabindex="0" aria-label="Lane Hopper game">
  <div id="scoreboard">Score: 0</div>
  <div id="bestscore">Best: 0</div>
  <div id="taphint">Swipe left/right or use ← → keys to switch lanes</div>
  <div id="player" class="player-car" aria-label="Player car"></div>
  <button id="playPauseBtn" aria-label="Pause game" title="Pause game">Pause</button>
</div>

<script>
(() => {
  const game = document.getElementById('game');
  const player = document.getElementById('player');
  const scoreboard = document.getElementById('scoreboard');
  const bestscoreElem = document.getElementById('bestscore');
  const taphint = document.getElementById('taphint');
  const playPauseBtn = document.getElementById('playPauseBtn');

  const laneWidth = 100;
  const carWidth = 30;
  const laneOffset = (laneWidth - carWidth) / 2;

  // 3 lanes: left(0), center(1), right(2)
  const lanes = [
    laneOffset,
    laneWidth + laneOffset,
    2 * laneWidth + laneOffset
  ];

  let playerLane = 1; // start in center lane

  let obstacles = [];
  let score = 0;
  let bestScore = 0;
  let speed = 1.6;
  let spawnInterval = 1800;
  let lastSpawn = 0;
  let lastFrameTime = 0;
  let gameOver = false;
  let paused = false;

  const maxSpeed = 6;

  const carColors = ['#e74c3c','#3498db','#f1c40f','#2ecc71','#9b59b6','#e67e22','#1abc9c','#e84393'];
  let currentSkinIndex = 0;

  function setPlayerSkin(index) {
    player.style.backgroundColor = carColors[index];
    player.style.boxShadow = `0 0 10px ${carColors[index]}`;
  }

  function createObstacle() {
    const obstacle = document.createElement('div');
    obstacle.classList.add('obstacle');

    const isCar = Math.random() < 0.7;
    if (isCar) {
      obstacle.dataset.type = 'car';
      obstacle.style.backgroundColor = carColors[(currentSkinIndex + 3) % carColors.length];
      obstacle.style.boxShadow = `0 0 10px ${carColors[(currentSkinIndex + 3) % carColors.length]}`;
    } else {
      obstacle.dataset.type = 'barrier';
      obstacle.style.background = 'repeating-linear-gradient(45deg, #666, #666 8px, #999 8px, #999 16px)';
      obstacle.style.boxShadow = '0 0 8px #888 inset';
    }

    obstacle.lane = Math.floor(Math.random() * 3);
    obstacle.style.left = lanes[obstacle.lane] + 'px';
    obstacle.style.top = '-70px';
    obstacle.pos = -70;

    game.appendChild(obstacle);
    obstacles.push(obstacle);
  }

  function updateObstacles(delta) {
    for (let i = obstacles.length - 1; i >= 0; i--) {
      const obs = obstacles[i];
      obs.pos += speed * delta;
      obs.style.top = obs.pos + 'px';

      if (obs.pos > game.clientHeight + 50) {
        obs.remove();
        obstacles.splice(i, 1);
        score++;
        scoreboard.textContent = 'Score: ' + score;

        if (score > bestScore) {
          bestScore = score;
          localStorage.setItem('laneHopperBest', bestScore);
          bestscoreElem.textContent = 'Best: ' + bestScore;
        }

        if (score % 10 === 0) {
          currentSkinIndex = (currentSkinIndex + 1) % carColors.length;
          setPlayerSkin(currentSkinIndex);
        }

        if (score % 5 === 0 && speed < maxSpeed) {
          speed = Math.min(maxSpeed, speed + 0.11);
          spawnInterval = Math.max(700, spawnInterval - 70);
        }
      }
    }
  }

  function checkCollision() {
    const playerRect = player.getBoundingClientRect();
    for (const obs of obstacles) {
      const obsRect = obs.getBoundingClientRect();
      const overlap = !(playerRect.right < obsRect.left ||
                        playerRect.left > obsRect.right ||
                        playerRect.bottom < obsRect.top ||
                        playerRect.top > obsRect.bottom);
      if (overlap) return true;
    }
    return false;
  }

  function resetGame() {
    obstacles.forEach(o => o.remove());
    obstacles = [];
    score = 0;
    speed = 1.6;
    spawnInterval = 1800;
    currentSkinIndex = 0;
    setPlayerSkin(currentSkinIndex);
    playerLane = 1;
    player.style.left = lanes[playerLane] + 'px';
    scoreboard.textContent = 'Score: 0';
    taphint.textContent = 'Swipe left/right or use ← → keys to switch lanes';
    taphint.style.opacity = 0.5;
    gameOver = false;
    paused = false;
    playPauseBtn.textContent = 'Pause';
    playPauseBtn.setAttribute('aria-label', 'Pause game');
    lastSpawn = 0;
    lastFrameTime = 0;
    requestAnimationFrame(gameLoop);
  }

  function gameLoop(time = 0) {
    if (gameOver || paused) return;

    const delta = (time - lastFrameTime) / 16;
    lastFrameTime = time;

    if (time - lastSpawn > spawnInterval) {
      createObstacle();
      lastSpawn = time;
    }

    updateObstacles(delta);

    if (checkCollision()) {
      gameOver = true;
      taphint.textContent = 'Game Over! Swipe or press key to restart';
      taphint.style.opacity = 1;
      return;
    }

    requestAnimationFrame(gameLoop);
  }

  // Move player lane left, bounded
  function moveLaneLeft() {
    if (gameOver || paused) return;
    if (playerLane > 0) {
      playerLane--;
      player.style.left = lanes[playerLane] + 'px';
      taphint.style.opacity = 0;
    }
  }

  // Move player lane right, bounded
  function moveLaneRight() {
    if (gameOver || paused) return;
    if (playerLane < lanes.length -1) {
      playerLane++;
      player.style.left = lanes[playerLane] + 'px';
      taphint.style.opacity = 0;
    }
  }

  // Handle keyboard arrows
  function onKeyDown(e) {
    if (gameOver) {
      resetGame();
      return;
    }
    if (paused) return;

    if (e.key === 'ArrowLeft') {
      e.preventDefault();
      moveLaneLeft();
    } else if (e.key === 'ArrowRight') {
      e.preventDefault();
      moveLaneRight();
    }
  }

  // Touch swipe detection variables
  let touchStartX = null;
  let touchStartY = null;
  const swipeThreshold = 30; // minimum px distance to be swipe

  function onTouchStart(e) {
    if (gameOver) return;
    if (e.touches && e.touches.length === 1) {
      touchStartX = e.touches[0].clientX;
      touchStartY = e.touches[0].clientY;
    }
  }

  function onTouchMove(e) {
    // prevent vertical scroll when swiping left/right in game
    if (!touchStartX) return;
    if (e.touches && e.touches.length === 1) {
      const dx = e.touches[0].clientX - touchStartX;
      const dy = e.touches[0].clientY - touchStartY;
      if (Math.abs(dx) > Math.abs(dy)) {
        e.preventDefault();
      }
    }
  }

  function onTouchEnd(e) {
    if (gameOver) {
      resetGame();
      return;
    }
    if (touchStartX === null) return;

    if (e.changedTouches && e.changedTouches.length === 1) {
      const touchEndX = e.changedTouches[0].clientX;
      const dx = touchEndX - touchStartX;

      if (Math.abs(dx) > swipeThreshold) {
        if (dx > 0) {
          moveLaneRight();
        } else {
          moveLaneLeft();
        }
      }
    }
    touchStartX = null;
    touchStartY = null;
  }

  // Play/pause toggle
  function togglePause() {
    if (gameOver) return; // can't pause after game over
    paused = !paused;
    if (!paused) {
      lastFrameTime = performance.now();
      requestAnimationFrame(gameLoop);
      playPauseBtn.textContent = 'Pause';
      playPauseBtn.setAttribute('aria-label', 'Pause game');
      taphint.style.opacity = 0.5;
    } else {
      playPauseBtn.textContent = 'Play';
      playPauseBtn.setAttribute('aria-label', 'Play game');
      taphint.style.opacity = 1;
      taphint.textContent = 'Paused';
    }
  }

  playPauseBtn.addEventListener('click', (e) => {
    e.stopPropagation(); // prevent triggering lane move on click
    togglePause();
  });

  // Restart game on click/tap if game over
  game.addEventListener('click', () => {
    if (gameOver) resetGame();
  });

  // Keyboard
  // Keyboard input event
  document.addEventListener('keydown', onKeyDown);

  // Touch events for mobile
  game.addEventListener('touchstart', onTouchStart, { passive: false });
  game.addEventListener('touchmove', onTouchMove, { passive: false });
  game.addEventListener('touchend', onTouchEnd);

  // Initial setup
  bestScore = parseInt(localStorage.getItem('laneHopperBest')) || 0;
  bestscoreElem.textContent = 'Best: ' + bestScore;
  player.style.left = lanes[playerLane] + 'px';
  setPlayerSkin(currentSkinIndex);
  requestAnimationFrame(gameLoop);
})();
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Snake Sprint (One-Button Snake) - Easy Mode</title>
<style>
  body {
    margin: 0; background: #111; display: flex; flex-direction: column; align-items: center; height: 100vh;
    color: #eee; font-family: monospace;
    user-select: none;
  }
  canvas {
    background: #222;
    image-rendering: pixelated;
    border: 2px solid #555;
    margin-top: 20px;
  }
  #info {
    font-size: 16px;
    text-align: center;
    user-select: none;
    margin-top: 10px;
  }
  #scoreboard {
    margin-top: 15px;
    text-align: center;
  }
  #scoreboard h2 {
    margin: 0 0 5px 0;
  }
  #scoreboard ol {
    padding-left: 20px;
    margin: 0;
  }
</style>
</head>
<body>

<div id="info">
  <div>Tap/Click or press Space/Arrows to turn clockwise<br>Score: <span id="score">0</span></div>
</div>
<canvas id="game" width="400" height="400"></canvas>

<div id="scoreboard">
  <h2>High Scores</h2>
  <ol id="highScoresList"></ol>
</div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const highScoresList = document.getElementById('highScoresList');
  
  const CELL_SIZE = 20;
  const COLS = canvas.width / CELL_SIZE;
  const ROWS = canvas.height / CELL_SIZE;

  // Directions as vectors
  const DIRS = {
    right: { x: 1, y: 0 },
    down: { x: 0, y: 1 },
    left: { x: -1, y: 0 },
    up: { x: 0, y: -1 },
  };
  const order = ['right', 'down', 'left', 'up']; // clockwise order for turning

  // Game variables
  let snake, directionIndex, direction, food, obstacles, score, foodTimer;
  const FOOD_LIFETIME = 12000; // 12 seconds before food disappears
  const OBSTACLE_COUNT = 7; // fewer obstacles for easy mode
  const FPS = 6; // slower speed

  // High score tracking (session only)
  let highScores = [];

  function reset() {
    // Start snake smaller for easier start
    snake = [
      { x: Math.floor(COLS/2) - 1, y: Math.floor(ROWS/2) }
    ];
    directionIndex = 0; // start moving right
    direction = DIRS[order[directionIndex]];
    score = 0;
    scoreEl.textContent = score;
    generateObstacles();
    placeFood();
  }

  function generateObstacles() {
    obstacles = [];
    // Place OBSTACLE_COUNT random obstacles avoiding snake start pos
    while (obstacles.length < OBSTACLE_COUNT) {
      const pos = {x: randInt(0, COLS-1), y: randInt(0, ROWS-1)};
      if (snake.some(s => s.x === pos.x && s.y === pos.y)) continue;
      if (obstacles.some(o => o.x === pos.x && o.y === pos.y)) continue;
      obstacles.push(pos);
    }
  }

  function placeFood() {
    let tries = 0;
    do {
      food = { x: randInt(0, COLS-1), y: randInt(0, ROWS-1) };
      tries++;
      if (tries > 100) break; // fallback
    } while (
      snake.some(s => s.x === food.x && s.y === food.y) ||
      obstacles.some(o => o.x === food.x && o.y === food.y)
    );
    foodTimer = Date.now();
  }

  function randInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  function drawCell(x, y, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw obstacles
    for (const o of obstacles) {
      drawCell(o.x, o.y, '#664422');
    }

    // Draw food (blink if almost expired)
    const timeLeft = FOOD_LIFETIME - (Date.now() - foodTimer);
    if (timeLeft > 0) {
      if (timeLeft < 1500 && Math.floor(Date.now()/200) % 2 === 0) {
        // blink effect near expiration (skip drawing food)
      } else {
        drawCell(food.x, food.y, '#FF5555');
      }
    }

    // Draw snake
    snake.forEach((segment, i) => {
      drawCell(segment.x, segment.y, i === snake.length - 1 ? '#00FF00' : '#009900');
    });
  }

  function update() {
    const head = snake[snake.length - 1];
    const newHead = { x: head.x + direction.x, y: head.y + direction.y };

    // Check collisions
    if (
      newHead.x < 0 || newHead.x >= COLS ||
      newHead.y < 0 || newHead.y >= ROWS ||
      snake.some(s => s.x === newHead.x && s.y === newHead.y) ||
      obstacles.some(o => o.x === newHead.x && o.y === newHead.y)
    ) {
      gameOver();
      return;
    }

    snake.push(newHead);

    // Check if ate food and food still valid
    if (food && newHead.x === food.x && newHead.y === food.y && (Date.now() - foodTimer) <= FOOD_LIFETIME) {
      score++;
      scoreEl.textContent = score;
      placeFood();
    } else {
      snake.shift();
    }

    // If food expired, place new food
    if (food && (Date.now() - foodTimer) > FOOD_LIFETIME) {
      placeFood();
    }
  }

  function turn() {
    directionIndex = (directionIndex + 1) % order.length;
    direction = DIRS[order[directionIndex]];
  }

  function gameOver() {
    alert(`Game Over! Your score: ${score}`);
    addHighScore(score);
    reset();
  }

  function addHighScore(score) {
    highScores.push(score);
    highScores.sort((a,b) => b - a);
    if (highScores.length > 5) highScores.length = 5; // keep top 5
    updateHighScoresUI();
  }

  function updateHighScoresUI() {
    highScoresList.innerHTML = highScores.map(s => `<li>${s}</li>`).join('');
  }

  function loop() {
    update();
    draw();
  }

  // Input
  window.addEventListener('keydown', e => {
    if (e.code === 'Space' || e.code.startsWith('Arrow')) {
      e.preventDefault();
      turn();
    }
  });
  window.addEventListener('mousedown', e => {
    e.preventDefault();
    turn();
  });
  window.addEventListener('touchstart', e => {
    e.preventDefault();
    turn();
  }, {passive: false});

  reset();
  setInterval(loop, 1000 / FPS);
})();
</script>

</body>
</html>
